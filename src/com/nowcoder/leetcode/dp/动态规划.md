### Dynamic Programming

#### 定义

动态规划就是==解决了重复计算==的搜索

#### 实现方式

- **循环**

  由小问题的解得到大问题的解。(小 —>大)

- **记忆化搜索**

  分治的思想，递归求解大问题，保存中间解避免重复计算。由于使用了递归，消耗系统栈，故记忆化搜索空间复杂度更高，但思考较为容易。(大—>小)

#### 基本要素

1. **状态** **State**

   存储小规模问题的结果

2. **方程 Function**

   状态之间的联系

3. **初始化 Intialization**

   最极限的小状态是什么, 起点

4. **答案 Answer**

   最大的那个状态是什么，终点

#### 常见类型

- **坐标型 (Matrix DP)**

  state: f\[x\]\[y\] 表示从起点到(x,y)的某一性质

  function: 研究走到x,y这个点之前的一步 

  intialize: 起点

  answer: 终点

  坐标型DP通常是研究某==一个点==的性质，dp数组通常开n个(new int[n])，初始化dp[0]。一维在for外初始化，二维最好在for内初始化。

  常见Leetcode题目：62不同路径、63不同路径||、64最小路径和、70爬楼梯、55跳跃游戏、45跳跃游戏||、120三角形最小路径和

- **序列型(Sequence DP)**

  state: f[i]表示前**i**个元素的某一性质 

  function: f[i] = g(f[i - 1]，nums[i]，nums[i - 1]) 

  intialize: f[0]..
  answer: f[n]

  序列型DP通常研究一个==序列==的性质，dp数组通常开n+1个(new int[n+1])，初始化dp[0]。

  关于序列型DP的初始化问题

  - 哪里需要初始化？

    递推关系中求不出来的解需要自己初始化(递推关系成立需要满足一些条件)

  - 怎样初始化？

    如果边界(即需要初始化的变量)有意义，则按照边界的意义初始化；若其无意义，则按照边界下一项(通过递推关系推出的)的意义初始化。

  注意：若使用dp\[i\]\[j\]表示一个序列的性质，则不能单独看i、j，要一起看(如j - i =1表示只有一个元素，单独看i，j没有意义)

  